# spBee - Stored Procedure Bee

This framework allows to declare the stored procedures calls declarative instead of programmatically. Only the
interfaces, the entities and few annotations need to be written. The code for the stored procedures, the
necessary entity mappers and the implementations of the DAO interfaces are generated by spBee.
It's also possible to use abstract classes instead of interfaces.

An important point is that there is no magic behind this framework like JPA/Hibernate with crazy reflection,
proxies and framework logic. The only logic is how to translate the annotations to the corresponding Java code.
Thereby spBee has only about 1700 LoC (measured with [sloc](https://www.npmjs.com/package/sloc)).

Everything is done at compile time. Therefore there is no performance shortcoming. No reflection. No proxies.

So some people will wonder why the hell should they use stored procedures?
Then read [my thoughts about](why-stored-procedures.html) that topic.


## Requirements

* Java 8
* Spring JDBC as dependency: which is used internally
* Spring Context for the Dependency Injection
    * Component scan needs to be configured to autowire the implementation of the generated classes
* ```spBee#core``` as dependency
* ```at.rseiler.spbee.core.SPBeeAnnotationProcessor``` as annotation processor

Spring is needed because spBee builds on top of ```org.springframework.jdbc.object.StoredProcedure``` and uses Spring`s
Dependency Injection.

__Important__: because spBee is not yet on the Maven Central Repository it's necessary to download the project and
install it yourself. Because spBee has a dependency on the [pom-project](https://github.com/rseiler/pom-project/) you
need first to download and install it. Or download the [jar file directly](builds/spbee-core-1.0.jar).

## How it works (short)

Within Java 1.6 it's possible to pre process annotations (before the code is compiled). In this pre process phase
it's also possible to generate code (Java source files or Java class files). spBee uses this mechanism to generate
the boilerplate code for the stored procedures, the entity mappers and the DAO implementations. spBee generates
readable Java code because this allows to set break points in the generated code. Another useful effect is that you
can just grab the generated files and work with them - you don't rely forever on spBee.


## How to configure spBee

Look at ```spBee#demo``` to see the a runnable project with minimal configuration to use spBee.

### Maven

In Maven you need to add spBee as dependency and define spBee`s annotation processor. That's it.

<div class="source">
<pre class="prettyprint lang-xml">
&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;version&gt;3.2&lt;/version&gt;
            &lt;configuration&gt;
                &lt;source&gt;1.8&lt;/source&gt;
                &lt;target&gt;1.8&lt;/target&gt;
                &lt;annotationProcessors&gt;
                    &lt;annotationProcessor&gt;
                        at.rseiler.spbee.core.SPBeeAnnotationProcessor
                    &lt;/annotationProcessor&gt;
                &lt;/annotationProcessors&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;at.rseiler.spbee&lt;/groupId&gt;
        &lt;artifactId&gt;core&lt;/artifactId&gt;
        &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</pre>
</div>

### Spring

In Spring you need to define the ```dataSource``` and the ```component-scan```. The component scan must include the
```@Dao``` annotated interfaces and abstract classes.

<div class="source">
<pre class="prettyprint lang-xml">
&lt;context:component-scan base-package="your.package.name"/&gt;

&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
    &lt;property name="driverClassName" value="org.hsqldb.jdbc.JDBCDriver"/&gt;
    &lt;property name="url" value="jdbc:hsqldb:mem:mymemdb"/&gt;
    &lt;property name="username" value="sa"/&gt;
    &lt;property name="password" value=""/&gt;
&lt;/bean&gt;
</pre>
</div>


## Simple Example

A simple example of the usage of spBee. The ```User``` class and the ```UserDao``` interface is all what is needed to
call the both stored procedures below and get the ```User``` objects.

<div class="source">
<pre class="prettyprint lang-java">
@Entity
public class User {

    private int id;
    private String name;

    private User() {
    }

    @MappingConstructor
    public User(int id, String name) {
        this(id, name);
    }

     public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }
}

@Dao
public interface UserDao {

    // list of entities
    @StoredProcedure("sp_get_users")
    List&lt;User&gt; getUsers();


    // single entity
    @StoredProcedure("sp_get_user")
    public User getUser(int id);

}

// execution
List&lt;User&gt; users = userDao.getUsers();
User user = userDao.getUser(1);
</pre>
</div>

<div class="source">
<pre class="prettyprint lang-sql">

CREATE PROCEDURE sp_get_users()
  READS SQL DATA
  DYNAMIC RESULT SETS 1
  BEGIN ATOMIC

    DECLARE resultUser CURSOR WITH RETURN FOR
      SELECT
        id,
        name
      FROM User;

    OPEN resultUser;
  END;

CREATE PROCEDURE sp_get_user(idUser INT)
READS SQL DATA
DYNAMIC RESULT SETS 1
BEGIN ATOMIC

  DECLARE resultUser CURSOR WITH RETURN FOR
    SELECT
      id,
      name
    FROM User
    WHERE id = idUser;

  OPEN resultUser;
END;

</pre>
</div>


## Return Types

The list of all possible return types of a stored procedure method.

### Void

It the stored procedure doesn't return anything. If the stored procedure nevertheless returns something then it's ignored.

### List

If the stored procedure returns several rows then just use a generic list as return type. If no row is
returned by the stored procedure then an empty list will be returned.

### Entity

The generated code will automatically retrieve the element from the list and return it.

* If no row is returned then a ```ObjectDoesNotExist``` runtime exception is thrown.
    * It's possible that in this case ```null``` is returned if the ```@ReturnNull``` annotation is used.
    * It's possible that in this case ```Optional.empty()``` is returned if the Entity is packed into an ```Optional``` type.
* If more than one row is returned then a ```MultipleObjectsReturn``` runtime exception is thrown.

### ResultSet

If the stored procedure returns several result sets then we need to model it in Java.
[Example](#example-result-set).

* Write a class which contains for each result set a corresponding field. These fields can be annotated with: ```@ReturnNull``` and ```@RowMapper```
* Create an corresponding constructor to initialize the fields.
* Annotate the written class with ```@ResultSet```.


## Important Notes

Please note that the order of the Java fields and parameters is important and must match the corresponding stored procedure.

### @StoredProcedure

The order of the parameters must be the same as the input parameters of the stored procedure.

As input parameters only basic types are allowed.
See [StoredProcedureGenerator](core/xref/at/rseiler/spbee/core/generator/StoredProcedureGenerator.html)#getSqlParameter.
If you use arrays then they must use the class kind not the primitive kind. E.g. use ```Integer[]``` instead of ```int[]```.
See [StoredProcedureGenerator](core/xref/at/rseiler/spbee/core/generator/StoredProcedureGenerator.html)#getArrayType.

### @Entity

The order of the parameters of the constructor must be the same as the columns of the stored procedure.

As constructor variables only basic types are allowed.
See [MapperGenerator](/core/xref/at/rseiler/spbee/core/generator/MapperGenerator.html)#getResultSetMethod.

### @ResultSet

The order of the class fields __and__ the parameters of the constructor must be the same as the returned result sets.

### ```@Dao``` Abstract Class

* the idea behind the abstract class is that it's possible to mix spBee methods with own methods
    * if some special calls to the database are needed which spBee doesn't support
    * if you don't want to return the result of the stored procedure directly. E.g.: in ```spBee#demo``` look at ```AbstractUserDao#getUserWithPermissions```.
* two kinds of constructors are supported
    * default constructor (no parameters)
    * constructor with ```javax.sql.DataSource``` as parameter


## Interceptor

The idea of the interceptor is to log and monitor the stored procedure calls. If a interceptor is configured then before
and after the stored procedure call the interceptor is called. It's not possible to modify the arguments of the stored
procedure call. The only thing what would be possible is to throw a RuntimeException to cancel the stored procedure
call.

The interceptor class must contain following method signatures:

<div class="source">
<pre class="prettyprint lang-java">
/**
 * This method will be called before the stored procedure call.
 *
 * @param spName    the name of the stored procedure
 * @param arguments the arguments of the stored procedure
 * @return the ID object to identify the call in the after method
 **/
public static Object before(String spName, Object... arguments)

/**
 * This method will be called after the invocation of the stored procedure.
 *
 * @param id        the ID object (returned from the before method)
 * @param spName    the name of the stored procedure
 * @param arguments the arguments of the stored procedure
 */
public static void after(Object id, String spName, Object... arguments)
</pre>
</div>

Then the ```spbee.properties``` file is required to be in the class path with the interceptor class configured:

    interceptor=at.rseiler.spbee.demo.SpLogger

In the ```spbee#demo``` module is an example of a stored procedure logger. See ```at.rseiler.spbee.demo.SpLogger```.


## Generated Classes

All non spBee related annotations will be added to the methods of the DAO implementation class.

Thereby it's possible to use the ```@Transactional``` annotation on the interface or the abstract class.

<table>
    <thead>
    <tr>
        <th>Type</th>
        <th>Pattern</th>
        <th>Description</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>DAO</td>
        <td>*.{CLASS_NAME}Impl</td>
        <td>
            The class name will be the name of the annotated class with <tt>Impl</tt> as postfix.<br/>
        </td>
    </tr>
    <tr>
        <td>Stored Procedure</td>
        <td>*.storedprocedure.{STORED_PROCEDURE_NAME}</td>
        <td>
            The class name will be the name of the stored procedure (defined in the <tt>@StoredProcedure</tt> annotation).
            But the name will be modified a little bit:<br/>
            The first character will be uppercase, underscores will be removed and the following character will be uppercase.<br/>
            The package is relative to the DAO.
        </td>
    </tr>
    <tr>
        <td>Mapper</td>
        <td>*.mapper.{ENTITY_NAME}{CONSTRUCTOR_NAME}Mapper</td>
        <td>
            The constructor name is <tt>Default</tt> if no other name is defined (with <tt>@MappingConstructor("some_constructor_name")</tt><br/>
            The package is relative to the entity.
        </td>
    </tr>
    </tbody>
</table>


## Annotations

<table>
    <thead>
    <tr>
        <th>Name</th>
        <th>Target</th>
        <th>Description</th>
    </tr>
    </thead>
    <tr>
        <td>@Dao</td>
        <td>TYPE</td>
        <td>Annotate the DAO with this annotation. Then spBee will generate the DAO implementation class.</td>
    </tr>
    <tr>
        <td>@Entity</td>
        <td>TYPE</td>
        <td>Annotate all entities which are used as return types in the stored procedure methods of the DAO.</td>
    </tr>
    <tr>
        <td>@MappingConstructor</td>
        <td>CONSTRUCTOR|METHOD|FIELD</td>
        <td>
            Annotate the constructors and give them names. These constructors will be used to create an entity
            instance. The names allow to use different views/subsets of an entity.
            <a href="#example-mapping-constructor">Example.</a>
        </td>
    </tr>
    <tr>
        <td>@ResultSet</td>
        <td>TYPE</td>
        <td>
            If an stored procedure returns several result sets then a Java class will represent these result sets. These
            class must be annotated with <tt>@ResultSet</tt>. The fields of the class describes the different result sets
            and the fields can be annotated with: <tt>@ReturnNull</tt> or <tt>@RowMapper</tt>.
            <a href="#example-result-set">Example.</a>
        </td>
    </tr>
    <tr>
        <td>@ReturnNull</td>
        <td>METHOD|FIELD</td>
        <td>
            If the stored procedure method just returns an entity (not a list of entities) and if no row is returned
            then the method will return <tt>null</tt>. <a href="#example-return-null">Example.</a>
        </td>
    </tr>
    <tr>
        <td>@RowMapper</td>
        <td>METHOD|FIELD</td>
        <td>
            The value defines the class of the mapper which should be used to map the entities. Instead of the generated
            default mappers.
            <a href="#example-row-mapper">Example.</a>
        </td>
    </tr>
    <tr>
        <td>@StoredProcedure</td>
        <td>METHOD</td>
        <td>
            The value defines the name of the stored procedure. Only methods annotated with @StoredProcedure will be
            processed by spBee.
        </td>
    </tr>
</table>


## More Examples

More examples can be found in the ```spBee#demo``` module.

### Multiple ```@ResultSet```s from the stored procedure <a name="example-result-set"></a>

<div class="source">
<pre class="prettyprint lang-java">

@ResultSet
public class UserPermissionsResultSet {

    @RowMapper(SimpleUserMapper.class)
    private final Optional&lt;User&gt; user;
    private final List&lt;Permission&gt; permissions;

    public UserPermissionsResultSet(Optional&lt;User&gt; user, List&lt;Permission&gt; permissions) {
        this.user = user;
        this.permissions = permissions;
    }

    public Optional&lt;User&gt; getUser() {
        if (user.isPresent()) {
            return Optional.of(new Builder(user.get()).permissions(permissions).build());
        }
        return Optional.empty();
    }

}


@Dao
public abstract class AbstractUserDao {

    @StoredProcedure("sp_get_user_with_permissions")
    public abstract UserPermissionsResultSet getUserWithPermissions(int id);

}

</pre>
</div>

### Use your own ```@RowMapper``` <a name="example-row-mapper"></a>

<div class="source">
<pre class="prettyprint lang-java">

public class SimpleUserMapper implements RowMapper&lt;User&gt; {

    public User mapRow(ResultSet rs, int rowNum) throws SQLException {
        return new User(
                rs.getInt(1),
                "not loaded",
                new ArrayList&lt;&gt;());
    }

}

</pre>
</div>

<div class="source">
<pre class="prettyprint lang-java">

@Dao
public interface UserDao {

    @RowMapper(SimpleUserMapper.class)
    @StoredProcedure("sp_get_simple_users")
    List&lt;User&gt; getSimpleUsersWithOwnMapper();

}

</pre>
</div>

<div class="source">
<pre class="prettyprint lang-java">

@ResultSet
public class UserPermissionsResultSet {

    @RowMapper(SimpleUserMapper.class)
    private final User user;
    private final List&lt;Permission&gt; permissions;

    public UserPermissionsResultSet(User user, List&lt;Permission&gt; permissions) {
        this.user = user;
        this.permissions = permissions;
    }
}

</pre>
</div>

### Return ```null``` instead of an ```ObjectDoesNotExist``` runtime exception <a name="example-return-null"></a>

<div class="source">
<pre class="prettyprint lang-java">

@Dao
public interface UserDao {

    @ReturnNull
    @StoredProcedure("sp_get_simple_user")
    User getUser();

}

@ResultSet
public class UserPermissionsResultSet {

    @ReturnNull
    private final User user;
    private final List&lt;Permission&gt; permissions;

    public UserPermissionsResultSet(Optional&lt;User&gt; user, List&lt;Permission&gt; permissions) {
        this.user = user;
        this.permissions = permissions;
    }
}

</pre>
</div>

### Return ```Optional.empty()``` instead of an ```ObjectDoesNotExist``` runtime exception <a name="example-return-null"></a>

<div class="source">
<pre class="prettyprint lang-java">

@Dao
public interface UserDao {

    @StoredProcedure("sp_get_simple_user")
    Optional&lt;User&gt; getUser();

}

@ResultSet
public class UserPermissionsResultSet {

    private final Optional&lt;User&gt; user;
    private final List&lt;Permission&gt; permissions;

    public UserPermissionsResultSet(Optional&lt;User&gt; user, List&lt;Permission&gt; permissions) {
        this.user = user;
        this.permissions = permissions;
    }
}

</pre>
</div>

### ```@MappingConstructor``` <a name="example-mapping-constructor"></a>

<div class="source">
<pre class="prettyprint lang-java">

@Entity
public class User {

    private final long loginId;
    private final String userName;
    private final int age;

    @MappingConstructor
    public User(long loginId, String userName, int age) {
        this.loginId = loginId;
        this.userName = userName;
        this.age = age;
    }

    @MappingConstructor("userCoreData")
    public User(long loginId, String userName) {
        this.loginId = loginId;
        this.userName = userName;
        this.age = -1;
    }

}

@Dao
public abstract class AbstractUserDao {

    @StoredProcedure("pr_get_user")
    public abstract User getUser(long loginId);

    @MappingConstructor("userCoreData")
    @StoredProcedure("pr_get_user_core_data")
    public abstract User getUserCoreData(long loginId);

}

</pre>
</div>
